<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Who With Whom, What With What - Blog</title><link rel=icon type=image/png href=img/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Using ILP for a decision making process."><meta property="og:image" content><meta property="og:url" content="https://kevinkle.in/posts/2022-06-21-friends/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="Who With Whom, What With What"><meta property="og:description" content="Using ILP for a decision making process."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-22T07:38:07+02:00"><meta property="article:modified_time" content="2022-06-22T07:38:07+02:00"><meta property="article:tag" content="Math"><meta name=twitter:card content="summary"><meta name=twitter:title content="Who With Whom, What With What"><meta name=twitter:description content="Using ILP for a decision making process."><script src=https://kevinkle.in/js/feather.min.js></script><link href=https://kevinkle.in/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://kevinkle.in/css/main.cd139160ccd0ca6bf7d891fb9f590f6c1f70199ff96cd189099b67d9081114e9.css></head><body><div class=content><header><div class=main><a href=https://kevinkle.in/>Blog</a></div><nav><a href=/about>Hello</a>
<a href=/tags>Tags</a>
<a href=/projects>Projects</a>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></nav></header><main><article><div class=title><h1 class=title>Who With Whom, What With What</h1><div class=meta>Posted on Jun 22, 2022</div></div><section class=body><p>The following is an illustration of a graph optimization problem. I chose to instantiate it with a decision making process
revolving around a social setting. Yet I hope its general applicability comes across.</p><h1 id=setup>Setup</h1><p>Let&rsquo;s say we have the opportunity to invite people to an event. The pool of candidates is comprised of five people: Tony, Paulie, Silvio, Furio and Vito. What we care about is for the attendants to have a good time - which we assume to be purely determined by who else is attending. If two people like each other and are both present, their experience improves. Put differently, we can think of &lsquo;value&rsquo; that the presence of a pair of people has<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Moreover, we assume that this pairwise value is independent of who else is there. For example, the presence of Tony is as valuable for Paulie when Silvio is presents as when Silvio is absent.</p><p>The following graph illustrates this situation; vertices representing people and edge weights representing pairwise value.</p><p><img src=/imgs/friends/friends.gv.png alt=image></p><p>Given that we cannot have all people over, but rather just \(n\), we would like to maximize the overall value created by the gathering, in true utalitarian fashion.</p><h1 id=solution>Solution</h1><p>As was previously mentioned, we can model every candidate as a vertex in a graph \(G = (V, E)\). Since we assume to know what the value of each co-occurrence is, we have a complete graph. In other words, every vertex is connected to every other vertex. Moreover we have edge weights \(w\) from an arbitrary numerical range, possibly negative.</p><p>Our challenge lies in finding a sub-graph/clique of cardinality \(n \leq |V|\) such that the sum of edge weights is maximal. We can formalize this to resemble to an <a href=https://en.wikipedia.org/wiki/Integer_programming>integer linear program</a> (ILP):</p><p>$$
\max_{S} \sum_{e_{i, j} \in E} \mathbb{I}[i \in S] \mathbb{I}[j \in S] w(e_{i, j}) \\
s.t.\ S \subset V, |S| = n
$$</p><p>Note that this is not an integer linear program quite yet. As of now, the product of indicator variables as well as the set notation are beyond scope. Therefore we will reprhase these slightly.</p><p>For that matter, we introduce binary variables \(x_{v_i}\) representing \(\mathbb{I}[v_i \in S]\) as well as binary variables \( x_{e_{i, j}} \) representing \( \mathbb{I}[e_{i, j} \in E]\). Thanks to the nature of our problem formulation &ndash; we always assume a subgraph to be complete &ndash; the set of selected edges logically follows from the set of selected vertices. Yet, since explicit logical conjunctions, i.e. \(x_{e_{i, j}} = x_{v_i} \wedge x_{v_j}\), are usually not permitted in integer linear programming, we have to find a way to create an implicit logical conjunction. We do so by imposing lower and upper bounds which ensure that intended behaviour <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>:</p><p>$$\begin{aligned}
& \max \sum_{i, j \in \mathcal{T}} x_{e_{i, j}} w_{i, j} \\
& s.t. \sum_{i \in \mathcal{I}} x_{v_i} = n \\
& \forall x_{e_{i, j}}: x_{e_{i, j}} \leq x_{v_{i}} \\
& \forall x_{e_{i, j}}: x_{e_{i, j}} \leq x_{v_{j}} \\
& \forall x_{e_{i, j}}: x_{e_{i, j}} \geq x_{v_{i}} + x_{v_{j}} - 1
\end{aligned}$$</p><p>where \( \mathcal{I}\) is a set of indices over all vertices/people and \(\mathcal{T}\) is a subset of \( \mathcal{I}^2\) such that</p><ul><li>no unordered pair of indices occurs twice and</li><li>no index co-occurrs with itself</li></ul><p>Translating this into Python code using <a href=https://coin-or.github.io/pulp/>PuLP</a>, this could look as follows - given initialized <code>friend_names</code> and <code>weight</code>, as well as a <code>SymmetricDict</code><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> pulp
</span></span><span style=display:flex><span>ilp <span style=color:#f92672>=</span> pulp<span style=color:#f92672>.</span>LpProblem(<span style=color:#e6db74>&#34;friends&#34;</span>, pulp<span style=color:#f92672>.</span>LpMaximize)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vertex_variable <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> name <span style=color:#f92672>in</span> friend_names:
</span></span><span style=display:flex><span>    vertex_variable[name] <span style=color:#f92672>=</span> pulp<span style=color:#f92672>.</span>LpVariable(name<span style=color:#f92672>=</span>name, cat<span style=color:#f92672>=</span>pulp<span style=color:#f92672>.</span>const<span style=color:#f92672>.</span>LpBinary)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>edge_variable <span style=color:#f92672>=</span> SymmetricDict()
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (i, j) <span style=color:#f92672>in</span> itertools<span style=color:#f92672>.</span>combinations(friend_names, <span style=color:#ae81ff>2</span>):
</span></span><span style=display:flex><span>    edge_variable[(i, j)] <span style=color:#f92672>=</span> pulp<span style=color:#f92672>.</span>LpVariable(name<span style=color:#f92672>=</span><span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>-</span><span style=color:#e6db74>{</span>j<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>, cat<span style=color:#f92672>=</span>pulp<span style=color:#f92672>.</span>const<span style=color:#f92672>.</span>LpBinary)
</span></span><span style=display:flex><span>	<span style=color:#75715e># Adding constraint ensuring edge is selected exectly when both of its vertices are selected.</span>
</span></span><span style=display:flex><span>    ilp <span style=color:#f92672>+=</span> edge_variable[(i, j)] <span style=color:#f92672>&lt;=</span> vertex_variable[i]
</span></span><span style=display:flex><span>    ilp <span style=color:#f92672>+=</span> edge_variable[(i, j)] <span style=color:#f92672>&lt;=</span> vertex_variable[j]
</span></span><span style=display:flex><span>	ilp <span style=color:#f92672>+=</span> edge_variable[(i, j)] <span style=color:#f92672>&gt;=</span> vertex_variable[i] <span style=color:#f92672>+</span> vertex_variable[j] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Adding constraint ensuring exactly n vertices are selected.</span>
</span></span><span style=display:flex><span>ilp <span style=color:#f92672>+=</span> sum(vertex_variable[i] <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> friend_names) <span style=color:#f92672>==</span> n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Adding an objective function.</span>
</span></span><span style=display:flex><span>ilp <span style=color:#f92672>+=</span> sum(
</span></span><span style=display:flex><span>    edge_variable[(i, j)] <span style=color:#f92672>*</span> weight[(i, j)]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, j <span style=color:#f92672>in</span> itertools<span style=color:#f92672>.</span>combinations(friend_names, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ilp<span style=color:#f92672>.</span>solve()
</span></span></code></pre></div><p>Running this for the example above with \(n=3\) leads to the following result:</p><p><img src=/imgs/friends/friends_selected.gv.png alt=image></p><p>Since solving an integer linear program is generally assumed to be NP-hard, we don&rsquo;t have reason to believe that this approach works for large input sizes. More precisely, PuLP uses <a href=https://github.com/coin-or/Cbc>CBC</a> as a default solver. I&rsquo;m not sure which algorithm it uses under the hood for integer linear programs. Yet, <a href=https://link.springer.com/article/10.1007/BF02579200>Frank et al</a> present an approach with runtime in \(c_v^{2.5 c_v} \mathcal{O}(poly(c_c, log(d)))\) where \(c_v\) is the number of variables, \(c_c\) the number of constraints and \(d\) the maximal value among constant coefficients. In our case we have</p><ul><li>\(c_v = |V| + {|V| \choose 2}\)</li><li>\(c_c = 3 {|V| \choose 2} + 1\)</li><li>\(d = n\)</li></ul><p>This should yield an asymptotic complexity of \(\mathcal{O}(|V|^{|V|} \cdot poly(|V|^2, log(n)) \). :(</p><h1 id=non-solutions>Non-solutions</h1><p>It is easy to show that the problem cannot be solved greedily. Consider the following graph:</p><p><img src=/imgs/friends/counterexample.png alt=image></p><p>We notice that the lavish edge weight between Tony and Silvio is a dealmaker for Tony to be part of the selection for \(n=2\), while Tony&rsquo;s other terrible edge weights prevent him from being part of the selection for \(n=3\).</p><p>Based on a similar intuition I&rsquo;m not particularly hopeful to solve this with <a href=https://en.wikipedia.org/wiki/Dynamic_programming>dynamic programming</a>.</p><p>I was wondering whether this problem could be reframed as a max flow min cut problem, which would allow for polynomial runtime complexity. So far I haven&rsquo;t found a way to do so. That said, I also haven&rsquo;t shown this problem to be in a particular complexity equivalence class. So who knows. <a href=https://arxiv.org/pdf/1810.10258.pdf>Shimizu et al</a> claim the slightly different maximum edge-weighted clique problem to be NP-hard. Yet, what is particular about our problem is that we know the size of the subgraph: \(n\). Hence, if we know \(n\) to be in in \(\mathcal{O}(1)\) with respect to the number of vertices \(|V|\), the brute force approach of runtime complexity \(\mathcal{O}({|V| \choose n} \cdot {n \choose 2})\) suddenly doesn&rsquo;t look so bad any more.</p><p>The code accompanying this exercise can be found <a href=https://github.com/kklein/whowithwhom>here</a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>For example, this pairwise value of Tony and Silvio being present could potentially express the mean of the value Tony creates for Silvio and the value Silvio creates for Tony.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>We observe that if \(\min(x_{v_i}, x_{v_j}) = 0\) then \(x_{v_i} + x_{v_j} -1 &lt; 0\). Given the binary nature of the variables, this forces \(x_{e_{i, j}}\) to equal 0. If, on the other hand, \(\min(x_{v_i}, x_{v_j}) = 1\), we know that the lower and upper bounds align: \(x_{v_i} = x_{v_j} = x_{v_i} + x_{v_j} -1 = 1\). As a consequence it holds that \(x_{e_{i, j}} = 1\).&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Since we are operating on an undirected graph, the edge \(e_{i, j}\) is indistinguishable from the edge \(e_{j, i}\). The responsibility of accounting for this symmetry can either</p><ul><li>be delegated to the user of a data structure, e.g. by duplicating values (data redundancy :() or by defining an unambigious access pattern or</li><li>be taken care of by the datastructure itself.</li></ul><p>Here, I opted for the latter by writing a simple wrapper around the Python dictionary.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SymmetricDict</span>(dict):
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sort_tuple</span>(cls, key):
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> tuple(sorted(key))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> __getitem__(self, key):
</span></span><span style=display:flex><span>		key <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__class__<span style=color:#f92672>.</span>sort_tuple(key)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> super()<span style=color:#f92672>.</span>__getitem__(key)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>def</span> __setitem__(self, key, value):
</span></span><span style=display:flex><span>		key <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__class__<span style=color:#f92672>.</span>sort_tuple(key)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> super()<span style=color:#f92672>.</span>__setitem__(key, value)
</span></span></code></pre></div><p>Fortunately, it seems to do what it&rsquo;s supposed to do:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>d <span style=color:#f92672>=</span> SymmetricDict()
</span></span><span style=display:flex><span>d[(<span style=color:#e6db74>&#34;Bob&#34;</span>, <span style=color:#e6db74>&#34;Anne&#34;</span>)] <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>d[(<span style=color:#e6db74>&#34;Anne&#34;</span>, <span style=color:#e6db74>&#34;Bob&#34;</span>)]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>d[(<span style=color:#e6db74>&#34;Bob&#34;</span>, <span style=color:#e6db74>&#34;Anne&#34;</span>)]
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#ae81ff>5</span>
</span></span></code></pre></div>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li></ol></div></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/math>math</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/kklein rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/kevkle rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a></div><div class=footer-info>2024 © Kevin Klein |</div></footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-SGRSG6Y0WX"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SGRSG6Y0WX")}</script><script>feather.replace()</script></div></body></html>