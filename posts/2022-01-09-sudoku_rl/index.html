<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Sudoku #3: Poor Man's RL - Blog</title><link rel=icon type=image/png href=img/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="I explored OpenAI's gym library to model Sudoku as a Reinforcement Learning problem."><meta property="og:image" content><meta property="og:title" content="Sudoku #3: Poor Man's RL"><meta property="og:description" content="I explored OpenAI's gym library to model Sudoku as a Reinforcement Learning problem."><meta property="og:type" content="article"><meta property="og:url" content="https://kevinkle.in/posts/2022-01-09-sudoku_rl/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-13T08:00:07+02:00"><meta property="article:modified_time" content="2022-02-13T08:00:07+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Sudoku #3: Poor Man's RL"><meta name=twitter:description content="I explored OpenAI's gym library to model Sudoku as a Reinforcement Learning problem."><script src=https://kevinkle.in/js/feather.min.js></script><link href=https://kevinkle.in/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://kevinkle.in/css/main.3a1de2917438aeff713f11261cc8e65bc6d4705113bc0ef12e161e5731d820b5.css></head><body><div class=content><header><div class=main><a href=https://kevinkle.in/>Blog</a></div><nav><a href=/about>Hello</a>
<a href=/tags>Tags</a>
<a href=/projects>Projects</a></nav></header><main><article><div class=title><h1 class=title>Sudoku #3: Poor Man's RL</h1><div class=meta>Posted on Feb 13, 2022</div></div><section class=body><p>Previously, I&rsquo;ve outlined some ideas on how to solve Suduko puzzles. One revolved around <a href=http://kevinkle.in/jekyll/update/2021/02/28/Sudoku_dfs.html>depth-first search in trees</a>, one around <a href=http://kevinkle.in/jekyll/update/2021/03/14/Sudoku_lp.html>linear programming</a>. This time I tried my luck with a more adventurous, data-driven approach: Reinforcement Learning. First things first: the approach only works well for 4x4 grids - not for the typical 9x9. Please note that the approached subsequently outlined couldn&rsquo;t be further from a recommendable approach to solving Sudoku puzzles. Rather, it is a curious exercise concerned with using the tool of Reinforcement Learning, arguable somewhat artificially, for solving particularly easy Sudoku puzzles.</p><h2 id=overview>Overview</h2><p>In <a href=https://en.wikipedia.org/wiki/Reinforcement_learning>Reinforcement Learning</a>, an agent is placed in an environment. Given a state, the agent can choose from a set of actions - to which the environment will &lsquo;respond&rsquo; with a &lsquo;reward&rsquo; as well as a new &lsquo;state&rsquo;. By trying out many combinations of states and actions and observing the resulting rewards, the agent can hopefully learn which actions make sense, when.</p><p>Since the notions of agent, state, reward are of a very general nature, one needs to define what they mean to represent concretely in a Reinforcement Learning application. This is were <a href=https://gym.openai.com/>OpenAI&rsquo;s gym</a> comes into play: it allows for a convenient definition and instantiation of environments. These environments complying with gym&rsquo;s universal interface comes with the advantage of being able to plug a wide variety of Machine Learning models into this environment without much hassle. Put differently: gym defines an interface which, if we adhere to it, allows us to use off-the-shelf models to train our agent.</p><p>To my surprise, I didn&rsquo;t stumble onto many resources and prior work when it comes to the pairing of Sudoku and Reinforcement Learning. Anav Mehta explored <a href=https://arxiv.org/abs/2102.06019>some approaches</a>. There were even some <a href=https://github.com/artonge/gym-Sudoku>gym Sudoku environments</a> available, though I couldn&rsquo;t find much about how to solve, i.e. train an agent, them reliably. Since this small project was meant as an exploration of gym, rather than Reinforcement Learning in general, I refrained from investing effort on agent model training but rather just played around with the environment definition.</p><h2 id=problem-definition>Problem definition</h2><p>While &lsquo;solving&rsquo; a Sudoku puzzle typically refers to</p><ol><li>a 9x9 grid</li><li>starting off with a grid with >1 missing cell values</li></ol><p>the scenario outlined here is a relaxed version thereof. We will consider</p><ol><li>both 4x4 and 9x9 grids</li><li>only seek to fill in a single (you can think of it as the &rsquo;last missing&rsquo;) cell value.</li></ol><h2 id=generating-examples>Generating examples</h2><p>In order for our agent to be able to (hopefully) learn from examples, we first need to generate examples. Most approaches for generating Sudoku boards I could find on google seemed to be based on starting off with empty boards and solving the puzzle from there. Since this project is about <em>solving Sudoku puzzles</em> I felt it would have been a little self-deprecating to use a <em>solver</em> in the process thereof. :)</p><p>Hence I resorted to a different approach: Generating a valid Sudoku board with a simple heuristic and applying random permutations to it, preserving the rules of the game.</p><h1 id=generating-a-valid-board>Generating a valid board</h1><p>Let&rsquo;s start off with a row:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>]
</span></span></code></pre></div><p>If we now replicate this row 8 times and always shift the values one index to the left/right, we already satisfy the column and row conditions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>size <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>[[(i <span style=color:#f92672>+</span> offset) <span style=color:#f92672>%</span> (size) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, size)] <span style=color:#66d9ef>for</span> offset <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, size)]
</span></span></code></pre></div><p>yielding</p><pre tabindex=0><code>[[0, 1, 2, 3, 4, 5, 6, 7, 8],
 [1, 2, 3, 4, 5, 6, 7, 8, 0],
 [2, 3, 4, 5, 6, 7, 8, 0, 1],
 [3, 4, 5, 6, 7, 8, 0, 1, 2],
 [4, 5, 6, 7, 8, 0, 1, 2, 3],
 [5, 6, 7, 8, 0, 1, 2, 3, 4],
 [6, 7, 8, 0, 1, 2, 3, 4, 5],
 [7, 8, 0, 1, 2, 3, 4, 5, 6],
 [8, 0, 1, 2, 3, 4, 5, 6, 7]]
</code></pre><p>Which is a 0-indexed Sudoku board - except for &lsquo;block&rsquo; conditions being violated. In other words: All of the 9 3x3 blocks contain several occurrences of the same value. No good.</p><p>In order to satisfy the block condition we apply some simple row shuffling:</p><ul><li>We want the first block to end up with the &lsquo;first&rsquo; row from every block.</li><li>We want the second block to end up with the &lsquo;second&rsquo; row from every block.</li><li>We want the third block to end up with the &rsquo;third&rsquo; row from every block.</li></ul><p>I&rsquo;m sure there&rsquo;s way neater - in any sense of neatness - approaches to doing this but e.g. this piece of code can get you there:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>size <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>rows <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    [(i <span style=color:#f92672>+</span> offset) <span style=color:#f92672>%</span> (size) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, size)] <span style=color:#66d9ef>for</span> offset <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, size)
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span>board <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array(rows, dtype<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>uint8)
</span></span><span style=display:flex><span>indeces <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>fromiter(
</span></span><span style=display:flex><span>	reduce(
</span></span><span style=display:flex><span>		chain,
</span></span><span style=display:flex><span>		map(
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>lambda</span> block_index: range(
</span></span><span style=display:flex><span>				block_index, block_index <span style=color:#f92672>+</span> ((n_blocks <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> n_blocks <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>), n_blocks
</span></span><span style=display:flex><span>			),
</span></span><span style=display:flex><span>			range(n_blocks),
</span></span><span style=display:flex><span>		),
</span></span><span style=display:flex><span>	),
</span></span><span style=display:flex><span>	dtype<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>uint8,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>reordered_board <span style=color:#f92672>=</span> board[indeces, :] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>Note that <code>range</code> is used with three parameters here: <code>start</code>, <code>stop</code> and <code>step</code>. Setting <code>step=n_blocks</code>, i.e. to 3, ensures that we bring together &lsquo;firsts&rsquo;, &lsquo;seconds&rsquo; and &rsquo;thirds&rsquo;. Running this and gives us a valid, 1-indexed Sudoku board:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>[[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>]]
</span></span></code></pre></div><p>Cool. Since we will use this valid board as a starting point for all of our random boards, we will want to make sure all of this doesn&rsquo;t need to be rerun every time we want to generate a random board. For that purpose I find it convenient to decorate the function running this code with <a href=https://docs.python.org/3/library/functools.html#functools.cache><code>@functools.cache</code></a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@functools.cache</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>valid_board</span>(n_blocks: int) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>ndarray:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><h1 id=generating-random-boards>Generating random boards</h1><p>Now that we have <em>a</em> valid board, would like to procedurally generate boards at random from a variety of boards. In order to do so we observe convenient properties of Sudoku boards:</p><ul><li>We can shuffle all row/columns arbitrarily within a block.</li><li>We can shuffle all row/column blocks arbitrarily.</li><li>We can apply arbitrary permutations to the digits 1 to 9.</li></ul><p>Yet, the first two operations cannot, a priori, be combined arbitrarily. What can be combined arbitrarily, is between-block and within-block shuffling of rows as well as between-block and within-block shuffling of columns. Put bluntly: When only shuffling columns or only shuffling rows as outlined before, all is always well.</p><p>Hence I decided to flip a coin every time a board was supposed to be generated: either to column or row shuffling (in <code>numpy</code> lingo, that is):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>axis <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>binomial(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0.5</span>)
</span></span></code></pre></div><p>In order to permute blocks, one can use simple <code>numpy</code> slicing. E.g. when shuffling row block #2 and block #3, one can do as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>new_board[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>6</span>, :] <span style=color:#f92672>=</span> old_board[<span style=color:#ae81ff>6</span>:<span style=color:#ae81ff>9</span>, :]
</span></span><span style=display:flex><span>new_board[<span style=color:#ae81ff>6</span>:<span style=color:#ae81ff>9</span>, :] <span style=color:#f92672>=</span> old_board[<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>6</span>, :]
</span></span></code></pre></div><p>In order to determine how we want to permute/shuffle blocks, we can simply use <code>numpy.random.permutation</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>permute_indeces</span>(indeces: np<span style=color:#f92672>.</span>ndarray) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>ndarray:
</span></span><span style=display:flex><span>    permutation <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>permutation(range(len(indeces)))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> indeces[permutation]
</span></span></code></pre></div><p>Combining the slicing mentioned before as well as the permutation highlighted just now, we can both shuffle entire row/column-blocks as well as rows/columns within blocks.</p><p>Tying this together could look as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># n_blocks indicates the size of a board.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># A board comprises n_boards**4 cells. </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>random_board</span>(n_blocks: int) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>ndarray:
</span></span><span style=display:flex><span>    old_board <span style=color:#f92672>=</span> valid_board(n_blocks)
</span></span><span style=display:flex><span>    new_board <span style=color:#f92672>=</span> old_board<span style=color:#f92672>.</span>copy()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Either permute rows or columns. If 1, permute rows.</span>
</span></span><span style=display:flex><span>    axis <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>binomial(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    permute_blocks(old_board, new_board, n_blocks, axis<span style=color:#f92672>=</span>axis)
</span></span><span style=display:flex><span>    permute_within_block_vectors(new_board, n_blocks, axis<span style=color:#f92672>=</span>axis)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> new_board
</span></span></code></pre></div><p>An example looks as follow:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>[[<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>]]
</span></span></code></pre></div><p>Additionally, we can apply arbitrary permutations to the digits 1 to 9. In other words, we can have a mapping, a bijective function, from the digits of 1..9 to 1..9. A way of doing
this is the tweak the function <code>valid_board</code> slightly from</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>valid_board</span>(n_blocks: int) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>ndarray:
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	rows <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>		[(i <span style=color:#f92672>+</span> offset) <span style=color:#f92672>%</span> (size) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, size)] <span style=color:#66d9ef>for</span> offset <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, size)
</span></span><span style=display:flex><span>	]
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span></code></pre></div><p>to</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>valid_board</span>(n_blocks: int, mapping: Sequence) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>ndarray:
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	rows <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>		[mapping[(i <span style=color:#f92672>+</span> offset) <span style=color:#f92672>%</span> (size)] <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, size)] <span style=color:#66d9ef>for</span> offset <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, size)
</span></span><span style=display:flex><span>	]
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span></code></pre></div><p>and call it e.g. as such:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>mapping <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>permutation(range(<span style=color:#ae81ff>9</span>))
</span></span><span style=display:flex><span>board <span style=color:#f92672>=</span> valid_board(<span style=color:#ae81ff>3</span>, mapping)
</span></span></code></pre></div><p>yielding, .e.g:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>[[<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>9</span>],
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>]]
</span></span></code></pre></div><p>I figure that a fairly natural question to ask at this point is how many different samples could be generated this way.
I&rsquo;m not sure about the overlap of the three permutation approaches. The number of permutations for 1 to 9 is a simple lower bound: 9!, i.e. <code>362_880</code> (or so tells me Google). We can obtain an upper bound by assuming no overlap.</p><p>Let&rsquo;s consider the number of boards generated via row permutation. There are 3! ways of shuffling the blocks. There are 3! ways of shuffling the rows per block. This should give us (3!)^4 = 1296 different boards. Assuming we create just as many distinct board via column permutation, we obtain an upper bound of 9!(3!)^8 ~ 600 billion, i.e. ~6 * 10^11, boards.</p><p>It&rsquo;s been shown surprisingly recently that there are <a href=http://www.afjarvis.staff.shef.ac.uk/Sudoku/Sudoku.pdf>roughly 6.671 x 10^21</a> valid boards. A bit of a stretch - to say the least - from what can be generated with the aforementioned procedure; even granting the very generous assumption of not having overlaps between permutations.</p><h2 id=gym-environment>Gym environment</h2><p>We define a <code>SudokuEnv</code> gym environment as a function of the number of blocks. For a standard Sudoku board, this would equal 3. The observations are Sudoku boards with at most one hole, represented by a 0. Hence we expect a grid with a minimal value of 0, a maximal value of <code>n_blocks ^ 2</code>, e.g. 9, and a shape of <code>n_blocks^2 x n_blocks^2</code>.</p><p>Importantly, since we assume only one hole in the grid, we can define the action space fairly narrowly: instead of choosing where to insert a number, we merely model what number to choose for the given hole. The action space, thereby, becomes the integers between 1 and <code>n_blocks^2</code>.</p><p>As some sort of analytical bookkeeping, we want to store information on which actions have been chosen how frequently in an environment - across different boards. As some people do in the sequential decision design and bandits literature, we&rsquo;ll call this &rsquo;empirical measurement plan&rsquo;:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SudokuEnv</span>(gym<span style=color:#f92672>.</span>Env):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, n_blocks: int):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>n_blocks <span style=color:#f92672>=</span> n_blocks
</span></span><span style=display:flex><span>        size <span style=color:#f92672>=</span> n_blocks <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>observation_space <span style=color:#f92672>=</span> gym<span style=color:#f92672>.</span>spaces<span style=color:#f92672>.</span>Box(
</span></span><span style=display:flex><span>            low<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, high<span style=color:#f92672>=</span>size, shape<span style=color:#f92672>=</span>(size, size), dtype<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>uint8
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        <span style=color:#75715e># The start keyword will only be supported in gym version &gt;0.21.0</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># self.action_space = gym.spaces.Discrete(size, start=1)</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>action_space <span style=color:#f92672>=</span> gym<span style=color:#f92672>.</span>spaces<span style=color:#f92672>.</span>Discrete(size)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_setup_boards()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>n_steps <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>empirical_measurement_plan <span style=color:#f92672>=</span> {action: <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>for</span> action <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, size <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_setup_boards</span>(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>board_solved <span style=color:#f92672>=</span> random_board(self<span style=color:#f92672>.</span>n_blocks)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>initial_board <span style=color:#f92672>=</span> almost_solved_board(self<span style=color:#f92672>.</span>board_solved)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>board <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>initial_board<span style=color:#f92672>.</span>copy()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>hole_indeces <span style=color:#f92672>=</span> hole_indeces(self<span style=color:#f92672>.</span>initial_board)
</span></span></code></pre></div><p>The only substantial thing left to do is to implement the <code>step</code> method, defining the logic around the action-taking. It mostly revolves around checking whether the chosen digit for the hole at hand actually solves the Sudoku board:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>step</span>(self, action: int) <span style=color:#f92672>-&gt;</span> tuple[np<span style=color:#f92672>.</span>ndarray, float, bool, dict]:
</span></span><span style=display:flex><span>        <span style=color:#75715e># See comment in `__init__`.</span>
</span></span><span style=display:flex><span>        action <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>empirical_measurement_plan[action] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>n_steps <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        x_index, y_index <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>hole_indeces
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>board[x_index, y_index] <span style=color:#f92672>=</span> action
</span></span><span style=display:flex><span>        done, reward <span style=color:#f92672>=</span> compare(self<span style=color:#f92672>.</span>board, self<span style=color:#f92672>.</span>board_solved)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> done:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>board[x_index, y_index] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>board,
</span></span><span style=display:flex><span>            float(reward),
</span></span><span style=display:flex><span>            done,
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;n_steps&#34;</span>: self<span style=color:#f92672>.</span>n_steps,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;empirical_measurement_plan&#34;</span>: self<span style=color:#f92672>.</span>empirical_measurement_plan,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        )
</span></span></code></pre></div><p>Note that somewhat arbitrary design decision to &lsquo;undo&rsquo; the action if the hole has not been successfully filled. For the sake of completeness, we should also have a <code>reset</code> method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>reset</span>(self) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>ndarray:
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_setup_boards()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_n_steps <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>board
</span></span></code></pre></div><h2 id=training-and-inference>Training and inference</h2><p>So far, we have only talked about the environment. As mentioned before, <code>gym</code> limits itself to the definition of an environment. The learning of an agent is delegated. I decided to use an off-the-shelf agent model from <a href=https://stable-baselines3.readthedocs.io/en/master/>`stable_baselines3</a>, relying on a <a href=https://stable-baselines3.readthedocs.io/en/master/modules/dqn.html#stable_baselines3.dqn.MlpPolicy>multi layer perceptron policy approximation</a>. The off-the-shelfness is likely a bad deal for actual performance but is indeed convenient:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> stable_baselines3 <span style=color:#f92672>import</span> DQN
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> Sudoku_env <span style=color:#f92672>import</span> SudokuEnv
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>N_BLOCKS <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>N_TIMESTEPS <span style=color:#f92672>=</span> <span style=color:#ae81ff>1_000_000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>env <span style=color:#f92672>=</span> SudokuEnv(n_blocks<span style=color:#f92672>=</span>N_BLOCKS)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>trained_model <span style=color:#f92672>=</span> DQN(<span style=color:#e6db74>&#34;MlpPolicy&#34;</span>, env, verbose<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>file_name <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Sudoku_</span><span style=color:#e6db74>{</span>N_BLOCKS<span style=color:#e6db74>}</span><span style=color:#e6db74>_</span><span style=color:#e6db74>{</span>N_TIMESTEPS<span style=color:#f92672>/</span><span style=color:#ae81ff>1_000_000</span><span style=color:#e6db74>}</span><span style=color:#e6db74>m&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>trained_model<span style=color:#f92672>.</span>learn(total_timesteps<span style=color:#f92672>=</span>N_TIMESTEPS)
</span></span><span style=display:flex><span>trained_model<span style=color:#f92672>.</span>save(file_name)
</span></span></code></pre></div><p>Once this agent model is trained, we can conveniently load it at a different time, from a different place and run inference based on it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> stable_baselines3 <span style=color:#f92672>import</span> DQN
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> Sudoku_env <span style=color:#f92672>import</span> SudokuEnv
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>N_BLOCKS <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>loaded_model <span style=color:#f92672>=</span> DQN<span style=color:#f92672>.</span>load(file_name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>env <span style=color:#f92672>=</span> SudokuEnv(n_blocks<span style=color:#f92672>=</span>N_BLOCKS)
</span></span><span style=display:flex><span>obs <span style=color:#f92672>=</span> env<span style=color:#f92672>.</span>board
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>action, _states <span style=color:#f92672>=</span> model<span style=color:#f92672>.</span>predict(obs, deterministic<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>obs, _, done, _ <span style=color:#f92672>=</span> env<span style=color:#f92672>.</span>step(action)
</span></span></code></pre></div><h2 id=results>Results</h2><p>Tl;dr: it didn&rsquo;t work.</p><p>For a <code>n_blocks</code> of 2, i.e. 4x4 Sudoku boards, training aforementioned model with 1m training steps leads to a model with an accuracy of 100% - evaluation samples being drawn from the same board-generation process than is used for training samples. It is therefore very possible that the model simply memorizes all constellations. It would be interesting to investigate this by either</p><ul><li>Excluding some samples from the training set and thereby constructing a holdout/test set.</li><li>Tweaking some training constellations as to be &lsquo;wrong&rsquo; Sudoku boards. If they are plainly replicated, thereby violating the rules of Sudoku, one can be sure that the model didn&rsquo;t actually distill an approach on how to <em>solve</em> a Sudoku puzzle.</li></ul><p>For a <code>n_blocks</code> of 3, i.e. 9x9 Sudoku boards, training aforementioned model with 10m training steps leads to a model with an accuracy of 15% on 1000 samples - hardly better than random guessing. The empirical measurement plan of the training process comes very close to a uniform distribution over the action space.</p><p>Two sample states with sample actions chosen:</p><pre tabindex=0><code>[[3 0 6 5 7 1 2 9 4]
 [2 9 4 3 8 6 5 7 1]
 [5 7 1 2 9 4 3 8 6]
 [6 5 7 1 2 9 4 3 8]
 [4 3 8 6 5 7 1 2 9]
 [1 2 9 4 3 8 6 5 7]
 [7 1 2 9 4 3 8 6 5]
 [9 4 3 8 6 5 7 1 2]
 [8 6 5 7 1 2 9 4 3]]
9
MISS :S
----
[[4 2 5 9 8 1 7 6 3]
 [7 6 3 4 2 5 9 8 1]
 [9 8 1 7 6 3 4 2 5]
 [8 1 7 6 3 4 2 5 9]
 [2 5 9 8 1 7 6 3 0]
 [6 3 4 2 5 9 8 1 7]
 [5 9 8 1 7 6 3 4 2]
 [1 7 6 3 4 2 5 9 8]
 [3 4 2 5 9 8 1 7 6]]
4
HIT!
</code></pre><h2 id=conclusion>Conclusion</h2><p>This was a cool exercise to think a bit about the generation of valid Sudoku boards as well as to warm up with <code>gym</code>&rsquo;s environment interface. The actual problem solving, machine learning work would only start here.</p><p>Moving forward, I figure one of the first things to look into would be to understand the neural network used by stable baselines better. Maybe its architecture obviously doesn&rsquo;t make any sense for this problem? Maybe one should look at the board as an image and rely on convolution? Is the model at all <em>improving</em> across training steps?</p><p>Also, as we all know, input data quality is quintessential. It might therefore make sense to <em>test</em> the data generation. Statistical tests, in stark contrast to formal reasoning, could be done by applying a board verification (e.g. as was used in previous posts) on a large sample of generated samples.</p><p>Maybe at a later point in time. :)</p><p>Code at <a href=https://github.com/kklein/sudoku>https://github.com/kklein/sudoku</a>.</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/math>math</a></li><li><a href=/tags/tech>tech</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/kklein title=GitHub><i data-feather=github></i></a><a class=soc href=https://twitter.com/kevkle title=Twitter><i data-feather=twitter></i></a></div><div class=footer-info>2023 © Kevin Klein |</div></footer><script>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-SGRSG6Y0WX","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><script>feather.replace()</script></div></body></html>